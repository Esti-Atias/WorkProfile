# WorkProfile CI/CD Pipeline
#
# This pipeline implements all 6 stages of the project requirements:
# 1. Basic Validation
# 2. Build and Test Application
# 3. 3-Tier Stack Testing
# 4. Publish (Push tested images to GHCR)
# 5. Kubernetes Deployment Testing
# 6. Manual Deployment Instructions

name: WorkProfile CI/CD Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  APP_PORT: 5000
  NGINX_PORT: 8080

jobs:
  # Stage 1 & 2: Basic Validation, Build and Test Application (Combined for efficiency)
  build_and_validate:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    outputs:
      full_image_name: ${{ steps.set_image_name.outputs.full_image_name }}
      new_tag: ${{ steps.increment_version.outputs.new_tag }}
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'

      - name: Install Python dependencies
        run: pip install -r requirements.txt pytest flake8

      - name: Run Basic Validation Tests
        run: |
          echo "=== Running Basic Validation Tests ==="
          python -c "import flask; print('✓ Flask import successful')" || { echo "ERROR: Flask import failed!"; exit 1; }
          python -c "import mysql.connector; print('✓ MySQL connector import successful')" || { echo "ERROR: MySQL connector failed!"; exit 1; }
          test -f Dockerfile && echo "✓ Dockerfile exists" || { echo "ERROR: Dockerfile missing!"; exit 1; }
          test -f requirements.txt && echo "✓ requirements.txt exists" || { echo "ERROR: requirements.txt missing!"; exit 1; }
          test -f src/app.py && echo "✓ app.py exists" || { echo "ERROR: app.py missing!"; exit 1; }
          test -f docker-compose/docker-compose.yml && echo "✓ docker-compose/docker-compose.yml exists" || { echo "ERROR: docker-compose/docker-compose.yml missing!"; exit 1; }
          test -f docker-compose/nginx.conf && echo "✓ nginx.conf exists" || { echo "ERROR: nginx.conf missing!"; exit 1; }
          test -f src/init.sql && echo "✓ src/init.sql exists" || { echo "ERROR: src/init.sql missing!"; exit 1; }
          echo "✅ Basic Validation Passed"

      - name: Run Unit Tests
        run: |
          echo "=== Running Unit Tests ==="
          pytest --disable-warnings tests/test_app.py || (echo "❌ Unit tests failed" && exit 1)
          echo "✅ Unit tests passed"

      - name: Set lowercase image name
        id: set_image_name
        run: |
          REPO_OWNER_LOWERCASE=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME_LOWERCASE=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          FULL_IMAGE_NAME="ghcr.io/$REPO_OWNER_LOWERCASE/$REPO_NAME_LOWERCASE"
          echo "full_image_name=$FULL_IMAGE_NAME" >> $GITHUB_OUTPUT

      - name: Get the latest tag from the repository and increment patch version
        id: increment_version
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git fetch --tags --force --prune
          
          latest_tag=$(git tag -l "v*" | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+$" | sort -V | tail -n 1)
          
          if [ -z "$latest_tag" ]; then
            new_tag="1.0.0"
          else
            version_only=$(echo "$latest_tag" | sed 's/^v//')
            IFS='.' read -r major minor patch <<< "$version_only"
            
            if ! [[ "$major" =~ ^[0-9]+$ && "$minor" =~ ^[0-9]+$ && "$patch" =~ ^[0-9]+$ ]]; then
              echo "ERROR: Invalid version format detected in latest tag: $latest_tag"
              new_tag="1.0.0"
            else
              patch=$((patch + 1))
              new_tag="${major}.${minor}.${patch}"
            fi
          fi
          
          if [ -z "$new_tag" ]; then
            echo "CRITICAL ERROR: new_tag is unexpectedly empty after all calculations! This should not happen."
            exit 1
          fi
          echo "new_tag=${new_tag}" >> $GITHUB_OUTPUT
          echo "VERSION_TAG=${new_tag}" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry (GHCR)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image to GHCR
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ steps.set_image_name.outputs.full_image_name }}:v${{ env.VERSION_TAG }}
            ${{ steps.set_image_name.outputs.full_image_name }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify image exists in GHCR after push
        run: |
          IMAGE_NAME_TO_CHECK="${{ steps.set_image_name.outputs.full_image_name }}:v${{ env.VERSION_TAG }}"
          docker manifest inspect "${IMAGE_NAME_TO_CHECK}" > /dev/null 2>&1
          if [ $? -eq 0 ]; then
            echo "✓ Image ${IMAGE_NAME_TO_CHECK} successfully found in GHCR."
          else
            echo "ERROR: Image ${IMAGE_NAME_TO_CHECK} NOT found in GHCR after push!"
            exit 1
          fi

      - name: Create GitHub Release
        if: github.ref == 'refs/heads/main'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.VERSION_TAG }}
          name: Release v${{ env.VERSION_TAG }}
          body: |
            - Auto-generated release
            - Image tag: v${{ env.VERSION_TAG }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Push Git tag
        if: github.ref == 'refs/heads/main'
        uses: actions/github-script@v6
        with:
          script: |
            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: 'refs/tags/v${{ env.VERSION_TAG }}',
                sha: context.sha
              });
              console.log('Successfully created Git tag: v${{ env.VERSION_TAG }}');
            } catch (error) {
              if (error.status === 422 && error.data.message.includes('Reference already exists')) {
                console.log('Git tag already exists, skipping creation.');
              } else {
                throw error;
              }
            }

  # Stage 3: 3-Tier Stack Testing
  three_tier_tests:
    runs-on: ubuntu-latest
    needs: build_and_validate
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Inject dynamic image tag into docker-compose.yml
        run: |
          IMAGE_TAG="${{ needs.build_and_validate.outputs.full_image_name }}:v${{ needs.build_and_validate.outputs.new_tag }}"
          sed -i "s|YOUR_APP_IMAGE_PLACEHOLDER|${IMAGE_TAG}|g" docker-compose/docker-compose.yml
          
      - name: Pull Docker Image for testing
        run: |
          IMAGE_TAG_USED=$(grep "image:" docker-compose/docker-compose.yml | awk '{print $2}' | head -n 1)
          docker pull "$IMAGE_TAG_USED" || { echo "ERROR: Failed to pull image $IMAGE_TAG_USED. Manifest unknown or incorrect tag?"; exit 1; }
          echo "Direct pull of $IMAGE_TAG_USED succeeded."

      - name: Bring up 3-Tier Stack
        working-directory: ./docker-compose
        run: |
          docker compose up -d --wait
          echo "Docker Compose services are up and healthy."

      - name: Check Nginx and App Health
        working-directory: ./docker-compose
        run: |
          echo "Waiting for services to be fully ready..."
          sleep 20 
          
          echo "Checking Nginx health..."
          curl -f http://localhost:${{ env.NGINX_PORT }}/ || { echo "ERROR: Nginx proxy failed! See logs below."; exit 1; }
          echo "✓ Nginx proxy works"
          curl -f http://localhost:${{ env.APP_PORT }}/health || { echo "ERROR: Health through nginx failed! See logs below."; exit 1; }
          echo "✓ Health through nginx works"

          HEALTH_RESPONSE=$(curl -s http://localhost:${{ env.APP_PORT }}/health)
          echo "$HEALTH_RESPONSE" | grep -q "Application: Healthy" || { echo "ERROR: Application health check failed! Response: $HEALTH_RESPONSE"; exit 1; }
          echo "✓ Application health check works"
          
      - name: Cleanup 3-Tier Stack
        if: always()
        working-directory: ./docker-compose
        run: |
          docker compose down -v || true

  # Stage 5: Kubernetes Deployment Testing
  kubernetes_deployment_testing:
    runs-on: ubuntu-latest
    needs: three_tier_tests
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Kind Cluster
        uses: kubernetes-sigs/kind@v1.2.0
        with:
          node_image: kindest/node:v1.28.0

      - name: Get and Load Docker Image into Kind Cluster
        id: load_image
        run: |
          FULL_IMAGE_NAME="${{ needs.build_and_validate.outputs.full_image_name }}"
          VERSION_TAG_WITH_V="v${{ needs.build_and_validate.outputs.new_tag }}"
          FULL_IMAGE_TAG="${FULL_IMAGE_NAME}:${VERSION_TAG_WITH_V}"
          
          # Pull the image that was pushed to GHCR
          echo "Attempting to pull image: ${FULL_IMAGE_TAG}"
          docker pull "${FULL_IMAGE_TAG}" || { echo "ERROR: Failed to pull image from GHCR. Check permissions and tag."; exit 1; }
          echo "Image pulled successfully."
          
          # Load the image into the Kind cluster
          echo "Loading image ${FULL_IMAGE_TAG} into Kind cluster..."
          kind load docker-image "${FULL_IMAGE_TAG}" || { echo "ERROR: Failed to load image into Kind cluster!"; exit 1; }
          echo "Image loaded successfully."
          
          echo "FULL_IMAGE_TAG=${FULL_IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Create imagePullSecret for GHCR
        run: |
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --docker-email=example@example.com

      - name: Inject dynamic image tag into original deployment YAML
        run: |
          ACTUAL_FULL_IMAGE_TAG="${{ steps.load_image.outputs.FULL_IMAGE_TAG }}"
          echo "Replacing IMAGE_PLACEHOLDER in k8s/workprofile-deployment.yaml with: ${ACTUAL_FULL_IMAGE_TAG}"
          sed -i "s|IMAGE_PLACEHOLDER|${ACTUAL_FULL_IMAGE_TAG}|g" k8s/workprofile-deployment.yaml
          cat k8s/workprofile-deployment.yaml

      - name: Deploy and Test Kubernetes Stack
        run: |
          echo "Deploying MySQL components..."
          kubectl apply -f k8s/mysql-secret.yaml
          kubectl create configmap mysql-initdb-script --from-file=../src/init.sql
          kubectl apply -f k8s/mysql-service-headless.yaml
          kubectl apply -f k8s/mysql-service-clusterip.yaml
          kubectl apply -f k8s/mysql-statefulset.yaml
          kubectl wait --for=condition=ready pod/mysql-0 --timeout=600s
          echo "✓ MySQL deployed successfully."

          echo "Deploying WorkProfile components..."
          kubectl apply -f k8s/workprofile-configmap.yaml
          kubectl apply -f k8s/workprofile-deployment.yaml
          kubectl apply -f k8s/workprofile-service.yaml
          kubectl wait --for=condition=available deployment/workprofile --timeout=600s
          echo "✓ WorkProfile deployed successfully."

          echo "Running Kubernetes health checks..."
          NODE_PORT=$(kubectl get service workprofile-service -o jsonpath='{.spec.ports[0].nodePort}')
          echo "WorkProfile NodePort: $NODE_PORT"
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          echo "Node IP: $NODE_IP"

          # Allow time for services to become fully ready
          sleep 10
          
          # Perform CURL tests
          curl -f http://$NODE_IP:$NODE_PORT/ && echo "✓ Kubernetes app works" || { echo "ERROR: Main endpoint failed!"; exit 1; }
          curl -f http://$NODE_IP:$NODE_PORT/health && echo "✓ Kubernetes health works" || { echo "ERROR: Health endpoint failed!"; exit 1; }
          curl -s http://$NODE_IP:$NODE_PORT/health | grep "Application: Healthy" && echo "✓ Kubernetes database works (via app health)" || { echo "ERROR: Database health check failed!"; exit 1; }
          echo "✓ All Kubernetes application tests passed."
          
      - name: Cleanup Kubernetes Cluster
        if: always()
        run: |
          kind delete cluster || true
          echo "Kind cluster deleted."

  # Stage 6: Manual Deployment Instructions
  manual-deployment-instructions:
    runs-on: ubuntu-latest
    needs: kubernetes_deployment_testing
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Display Deployment Instructions
        run: |
          TAG="${{ needs.build_and_validate.outputs.new_tag }}"
          REPO_OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME_LOWER=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          IMAGE_TO_DEPLOY="ghcr.io/${REPO_OWNER_LOWER}/${REPO_NAME_LOWER}:v${TAG}"

          echo "=== CI/CD Pipeline Complete! ==="
          echo ""
          echo "Your production-ready stack is ready! To deploy manually to Killercoda:"
          echo ""
          echo "1. In your Killercoda terminal, clone and prepare:"
          echo "     git clone https://github.com/${{ github.repository }}.git"
          echo "     cd WorkProfile"
          echo ""
          echo "2. Inject image tag and deploy:"
          echo "     IMAGE_TO_DEPLOY=\"${IMAGE_TO_DEPLOY}\""
          echo "     sed \"s|YOUR_APP_IMAGE_PLACEHOLDER|\$IMAGE_TO_DEPLOY|g\" k8s/workprofile-deployment.yaml > workprofile-deployment-temp.yaml"
          echo "     echo \"\""
          echo "     echo \"--- בדיקת התוכן ---\""
          echo "     cat workprofile-deployment-temp.yaml"
          echo "     echo \"\""
          echo ""
          echo "3. Deploy MySQL infrastructure first:"
          echo "     kubectl apply -f k8s/mysql-secret.yaml"
          echo "     kubectl apply -f k8s/mysql-statefulset.yaml"
          echo "     kubectl apply -f k8s/mysql-service-headless.yaml"
          echo "     kubectl apply -f k8s/mysql-service-clusterip.yaml"
          echo "     kubectl wait --for=condition=ready pod/mysql-0 --timeout=600s"
          echo ""
          echo "4. Deploy Workprofile application:"
          echo "     kubectl apply -f k8s/workprofile-configmap.yaml"
          echo "     kubectl apply -f k8s/workprofile-deployment.yaml"
          echo "     kubectl apply -f k8s/workprofile-service.yaml"
          echo "     kubectl wait --for=condition=available deployment/workprofile --timeout=600s"
          echo ""
          echo "5. Run health checks:"
          echo "     NODE_PORT=\$(kubectl get service workprofile-service -o jsonpath='{.spec.ports[0].nodePort}')"
          echo "     echo \"WorkProfile NodePort: \$NODE_PORT\""
          echo ""
          echo "     NODE_IP=\$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type==\"InternalIP\")].address}')"
          echo "     echo \"Node IP: \$NODE_IP\""
          echo ""
          echo "     curl -f http://\$NODE_IP:\$NODE_PORT/ && echo \"✓ Kubernetes app works\""
          echo "     curl -f http://\$NODE_IP:\$NODE_PORT/health && echo \"✓ Kubernetes health works\""
          echo "     curl -s http://\$NODE_IP:\$NODE_PORT/health | grep \"Application: Healthy\" && echo \"✓ Kubernetes database works (via app health)\""
          echo ""
          echo "6. Cleanup your environment:"
          echo "     kubectl delete -f k8s/mysql-secret.yaml"
          echo "     kubectl delete -f k8s/mysql-service-headless.yaml"
          echo "     kubectl delete -f k8s/mysql-service-clusterip.yaml"
          echo "     kubectl delete -f k8s/mysql-statefulset.yaml"
          echo "     kubectl delete -f k8s/workprofile-configmap.yaml"
          echo "     kubectl delete -f k8s/workprofile-service.yaml"
          echo "     kubectl delete -f workprofile-deployment.yaml"
          echo "     kubectl delete pvc mysql-persistent-storage-mysql-0"
          echo "     rm workprofile-deployment-temp.yaml"
          echo ""
          echo "=== Production Architecture Deployed ==="
