name: WorkProfile CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

permissions:
  contents: write
  packages: write
  id-token: write

env:
  APP_PORT: 5000
  NGINX_PORT: 8080

jobs:
  # Stage 1: Basic Validation
  basic_validation:
    runs-on: ubuntu-latest
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'

      - name: Install Python dependencies
        run: pip install -r requirements.txt

      - name: Run Basic Validation Tests
        run: |
          python -c "import flask; print('✓ Flask import successful')" || { echo "ERROR: Flask import failed!"; exit 1; }
          python -c "import mysql.connector; print('✓ MySQL connector import successful')" || { echo "ERROR: MySQL connector failed!"; exit 1; }
          test -f Dockerfile && echo "✓ Dockerfile exists" || { echo "ERROR: Dockerfile missing!"; exit 1; }
          test -f requirements.txt && echo "✓ requirements.txt exists" || { echo "ERROR: requirements.txt missing!"; exit 1; }
          test -f src/app.py && echo "✓ app.py exists" || { echo "ERROR: app.py missing!"; exit 1; }
          test -f docker-compose/docker-compose.yml && echo "✓ docker-compose/docker-compose.yml exists" || { echo "ERROR: docker-compose/docker-compose.yml missing!"; exit 1; }
          test -f docker-compose/nginx.conf && echo "✓ nginx.conf exists" || { echo "ERROR: nginx.conf missing!"; exit 1; }
          test -f src/init.sql && echo "✓ src/init.sql exists" || { echo "ERROR: src/init.sql missing!"; exit 1; }

  # Stage 2: Build and Test Application
  build_and_test_app:
    runs-on: ubuntu-latest
    needs: basic_validation # תלוי בשלב 1
    permissions:
      contents: write
      packages: write
    outputs:
      full_image_name: ${{ steps.set_image_name.outputs.full_image_name }}
      new_tag: ${{ steps.increment_version.outputs.new_tag }}
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry (GHCR)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set lowercase image name
        id: set_image_name
        run: |
          REPO_OWNER_LOWERCASE=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME_LOWERCASE=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          FULL_IMAGE_NAME="ghcr.io/$REPO_OWNER_LOWERCASE/$REPO_NAME_LOWERCASE"
          echo "full_image_name=$FULL_IMAGE_NAME" >> $GITHUB_OUTPUT

      - name: Get the latest tag from the repository and increment patch version
        id: increment_version
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git fetch --tags --force --prune
          
          latest_tag=$(git tag -l "v*" | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+$" | sort -V | tail -n 1)
          
          if [ -z "$latest_tag" ]; then
            new_tag="1.0.0"
          else
            version_only=$(echo "$latest_tag" | sed 's/^v//')
            IFS='.' read -r major minor patch <<< "$version_only"
            
            if ! [[ "$major" =~ ^[0-9]+$ && "$minor" =~ ^[0-9]+$ && "$patch" =~ ^[0-9]+$ ]]; then
              echo "ERROR: Invalid version format detected in latest tag: $latest_tag"
              new_tag="1.0.0"
            else
              patch=$((patch + 1))
              new_tag="${major}.${minor}.${patch}"
            fi
          fi
          
          if [ -z "$new_tag" ]; then
            echo "CRITICAL ERROR: new_tag is unexpectedly empty after all calculations! This should not happen."
            exit 1
          fi
          echo "new_tag=${new_tag}" >> $GITHUB_OUTPUT
          echo "VERSION_TAG=${new_tag}" >> $GITHUB_ENV

      - name: Build and push Docker image to GHCR (temporary push for testing)
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ steps.set_image_name.outputs.full_image_name }}:v${{ env.VERSION_TAG }}
            ${{ steps.set_image_name.outputs.full_image_name }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify image exists in GHCR after push
        run: |
          IMAGE_NAME_TO_CHECK="${{ steps.set_image_name.outputs.full_image_name }}:v${{ env.VERSION_TAG }}"
          docker manifest inspect "${IMAGE_NAME_TO_CHECK}" > /dev/null 2>&1
          if [ $? -eq 0 ]; then
            echo "✓ Image ${IMAGE_NAME_TO_CHECK} successfully found in GHCR."
          else
            echo "ERROR: Image ${IMAGE_NAME_TO_CHECK} NOT found in GHCR after push!"
            exit 1
          חשוב לזכור:
          * ה-CI/CD ירוץ על כל פוש ל-`main` ועל כל Pull Request.
          * שלב 5 (בדיקות קוברנטס) ייקח זמן, כ-5-10 דקות, מכיוון שהוא בונה קלאסטר `kind` מאפס.
          * הודעות השגיאה ב-GitHub Actions הן מפורטות, ואם תצוץ בעיה, נוכל לנתח אותה יחד.

