name: WorkProfile CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  APP_PORT: 5000
  NGINX_PORT: 8080

jobs:
  build_and_validate:
    runs-on: ubuntu-latest
    outputs:
      full_image_name: ${{ steps.set_image_name.outputs.full_image_name }}
      new_tag: ${{ steps.increment_version.outputs.new_tag }} # new_tag will be just the number (e.g., 1.1.6)
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'

      - name: Install Python dependencies
        run: pip install -r requirements.txt

      - name: Run Basic Validation Tests
        run: |
          python -c "import flask; print('✓ Flask import successful')" || { echo "ERROR: Flask import failed!"; exit 1; }
          python -c "import mysql.connector; print('✓ MySQL connector import successful')" || { echo "ERROR: MySQL connector import failed!"; exit 1; }
          test -f Dockerfile && echo "✓ Dockerfile exists" || { echo "ERROR: Dockerfile missing!"; exit 1; }
          test -f requirements.txt && echo "✓ requirements.txt exists" || { echo "ERROR: requirements.txt missing!"; exit 1; }
          test -f src/app.py && echo "✓ app.py exists" || { echo "ERROR: app.py missing!"; exit 1; }
          test -f docker-compose/docker-compose.yml && echo "✓ docker-compose/docker-compose.yml exists" || { echo "ERROR: docker-compose/docker-compose.yml missing!"; exit 1; }
          test -f docker-compose/nginx.conf && echo "✓ nginx.conf exists" || { echo "ERROR: nginx.conf missing!"; exit 1; }
          test -f src/init.sql && echo "✓ src/init.sql exists" || { echo "ERROR: src/init.sql missing!"; exit 1; }

      - name: Set lowercase image name
        id: set_image_name
        run: |
          REPO_OWNER_LOWERCASE=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME_LOWERCASE=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          FULL_IMAGE_NAME="ghcr.io/$REPO_OWNER_LOWERCASE/$REPO_NAME_LOWERCASE"
          echo "full_image_name=$FULL_IMAGE_NAME" >> $GITHUB_OUTPUT

      - name: Get the latest tag from the repository and increment patch version
        id: increment_version
        run: |
          git fetch --tags
          latest_tag=$(git tag -l "v*" | sort -V | tail -n 1)
          if [ -z "$latest_tag" ]; then
            new_tag="1.0.0"
          else
            major=$(echo $latest_tag | cut -d '.' -f 1 | sed 's/v//')
            minor=$(echo $latest_tag | cut -d '.' -f 2)
            patch=$(echo $latest_tag | cut -d '.' -f 3)
            patch=$((patch + 1))
            new_tag="${major}.${minor}.${patch}"
          fi
          echo "new_tag=$new_tag" >> $GITHUB_OUTPUT # This output will be just the number (e.g., 1.1.6)
          echo "VERSION_TAG=$new_tag" >> $GITHUB_ENV # This env var will also be just the number (e.g., 1.1.6)
          echo "Calculated new_tag: ${{ env.VERSION_TAG }}" # Added logging (will show 1.1.6)

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry (GHCR)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image to GHCR
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ steps.set_image_name.outputs.full_image_name }}:v${{ env.VERSION_TAG }} # Correct tag format
            ${{ steps.set_image_name.outputs.full_image_name }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify image exists in GHCR after push
        run: |
          # Check for the tag with 'v' prefix
          IMAGE_NAME_TO_CHECK="${{ steps.set_image_name.outputs.full_image_name }}:v${{ env.VERSION_TAG }}"
          echo "Verifying that image ${IMAGE_NAME_TO_CHECK} exists in GHCR..."
          docker manifest inspect "${IMAGE_NAME_TO_CHECK}" > /dev/null 2>&1
          if [ $? -eq 0 ]; then
            echo "✓ Image ${IMAGE_NAME_TO_CHECK} successfully found in GHCR."
          else
            echo "ERROR: Image ${IMAGE_NAME_TO_CHECK} NOT found in GHCR after push!"
            exit 1
          fi

      - name: Push Git tag
        if: github.ref == 'refs/heads/main'
        uses: actions/github-script@v6
        with:
          script: |
            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: 'refs/tags/v${{ env.VERSION_TAG }}', # Add 'v' here to create tag like v1.1.6
                sha: context.sha
              });
              console.log('Successfully created Git tag: v${{ env.VERSION_TAG }}');
            } catch (error) {
              if (error.status === 422 && error.data.message.includes('Reference already exists')) {
                console.log('Git tag already exists, skipping creation.');
              } else {
                throw error;
              }
            }
  
  single_container_tests:
    runs-on: ubuntu-latest
    needs: build_and_validate
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Load Docker Image from GHCR for testing
        run: |
          IMAGE_FULL_NAME=$(echo "${{ needs.build_and_validate.outputs.full_image_name }}" | tr -d '\n')
          # Construct the tag with 'v' prefix from the new_tag output
          VERSION_TAG_WITH_V="v$(echo "${{ needs.build_and_validate.outputs.new_tag }}" | tr -d '\n')"
          
          echo "Attempting to pull image: ${IMAGE_FULL_NAME}:${VERSION_TAG_WITH_V}"
          # Explicitly try to pull the image. If it fails, try 'latest'
          docker pull "${IMAGE_FULL_NAME}:${VERSION_TAG_WITH_V}" || \
          (echo "Pulling specific version failed, attempting to pull latest: ${IMAGE_FULL_NAME}:latest" && docker pull "${IMAGE_FULL_NAME}:latest") || \
          { echo "ERROR: Failed to pull image. Check GHCR and previous job logs."; exit 1; }
          echo "Image pulled successfully."


      - name: Run Single Container Tests
        run: |
          # Use IMAGE_FULL_NAME and VERSION_TAG_WITH_V defined in the previous step
          IMAGE_FULL_NAME=$(echo "${{ needs.build_and_validate.outputs.full_image_name }}" | tr -d '\n')
          VERSION_TAG_WITH_V="v$(echo "${{ needs.build_and_validate.outputs.new_tag }}" | tr -d '\n')"

          echo "Running container with image: ${IMAGE_FULL_NAME}:${VERSION_TAG_WITH_V}"
          docker run -d -p ${{ env.APP_PORT }}:${{ env.APP_PORT }} --name test-app ${IMAGE_FULL_NAME}:${VERSION_TAG_WITH_V}

          for i in {1..20}; do
            if curl -s http://localhost:${{ env.APP_PORT }}/health | grep -q "Application: Healthy"; then
              echo "App is ready!"
              break
            fi
            echo "Attempt $i: App not ready yet. Waiting..."
            sleep 3
          done
          curl -f http://localhost:${{ env.APP_PORT }}/health | grep -q "Application: Healthy" || { echo "ERROR: App did not become ready in time."; exit 1; }

          curl -f http://localhost:${{ env.APP_PORT }}/ && echo "✓ Main endpoint works" || { echo "ERROR: Main endpoint failed!"; exit 1; }
          curl -f http://localhost:${{ env.APP_PORT }}/health && echo "✓ Health endpoint works" || { echo "ERROR: Health endpoint failed!"; exit 1; }
      
      - name: Cleanup Single Container
        if: always()
        run: |
          docker stop test-app && docker rm test-app || true

  three_tier_tests:
    runs-on: ubuntu-latest
    needs: single_container_tests
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set lowercase image name
        id: set_image_name_for_compose
        run: |
          REPO_OWNER_LOWERCASE=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME_LOWERCASE=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          FULL_IMAGE_NAME="ghcr.io/$REPO_OWNER_LOWERCASE/$REPO_NAME_LOWERCASE"
          echo "full_image_name=$FULL_IMAGE_NAME" >> $GITHUB_OUTPUT
      
      - name: Run 3-Tier Stack Tests
        working-directory: ./docker-compose
        run: |
          # It's important that your docker-compose.yml references the image with the correct 'v' prefix.
          # If your docker-compose.yml uses a fixed image name, update it to use the new_tag output,
          # or ensure it pulls the 'latest' tag.
          # For example, in your docker-compose.yml, the 'image' field for your app service should look like:
          # image: ghcr.io/esti-atias/workprofile:v${VERSION_TAG} or ghcr.io/esti-atias/workprofile:latest
          # And you'd need to pass VERSION_TAG as an environment variable or build arg to compose,
          # or simply rely on 'latest' if you're pushing it consistently.
          docker compose up -d --build

          sleep 90

          curl -f http://localhost:${{ env.NGINX_PORT }}/ && echo "✓ Nginx proxy works" || { echo "ERROR: Nginx proxy failed!"; exit 1; }
          curl -f http://localhost:${{ env.NGINX_PORT }}/health && echo "✓ Health through nginx works" || { echo "ERROR: Health through nginx failed!"; exit 1; }

          HEALTH_RESPONSE=$(curl -s http://localhost:${{ env.NGINX_PORT }}/health)
          echo "$HEALTH_RESPONSE" | grep -q "Application: Healthy" && echo "✓ Application health check works" || { echo "ERROR: Application health check failed!"; exit 1; }
          echo "$HEALTH_RESPONSE" | grep -q "Database: Healthy" && echo "✓ Database connectivity works" || { echo "ERROR: Database connectivity failed!"; exit 1; }
      
      - name: Cleanup 3-Tier Stack
        if: always()
        working-directory: ./docker-compose
        run: |
          docker compose down -v || true

  publish:
    runs-on: ubuntu-latest
    needs: three_tier_tests
    if: github.ref == 'refs/heads/main'

    steps:
      - name: All previous steps completed, image already published.
        run: echo "Image was already built and pushed in the 'build_and_validate' job."