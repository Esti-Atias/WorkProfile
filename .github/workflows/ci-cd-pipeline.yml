# WorkProfile CI/CD Pipeline
#
# This pipeline implements all 6 stages of the project requirements:
# 1. Basic Validation
# 2. Build and Test Application
# 3. 3-Tier Stack Testing
# 4. Publish (Push tested images to GHCR)
# 5. Kubernetes Deployment Testing
# 6. Manual Deployment Instructions

name: WorkProfile CI/CD Pipeline

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  IMAGE_NAME: workprofile
  REGISTRY: ghcr.io

jobs:
  # Stage 1 & 2: Basic Validation, Build and Test Application (Combined for efficiency)
  build-and-test:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Needed for checking out code
      packages: write  # Needed for later push, but good practice to have here
    
    outputs:
      tag: ${{ steps.generate-tag.outputs.tag }} # The unique version tag to be used by other jobs
      full_image_name: ${{ steps.set-image-name.outputs.full_image_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies and pytest
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt pytest flake8

      - name: Run Basic Validation and Unit Tests
        # Combines the requirements of Stage 1 (file checks) and Stage 2 (unit tests)
        run: |
          echo "=== Running Basic Validation and Unit Tests ==="
          
          # Stage 1: Basic Validation Tests
          python -c "import flask; print('✓ Flask import successful')" || { echo "ERROR: Flask import failed!"; exit 1; }
          python -c "import mysql.connector; print('✓ MySQL connector import successful')" || { echo "ERROR: MySQL connector failed!"; exit 1; }
          test -f Dockerfile && echo "✓ Dockerfile exists" || { echo "ERROR: Dockerfile missing!"; exit 1; }
          test -f requirements.txt && echo "✓ requirements.txt exists" || { echo "ERROR: requirements.txt missing!"; exit 1; }
          test -f src/app.py && echo "✓ app.py exists" || { echo "ERROR: app.py missing!"; exit 1; }
          
          echo "✅ Basic Validation Passed"

          # Stage 2: Run Unit Tests
          pytest --disable-warnings tests/test_app.py || (echo "❌ Unit tests failed" && exit 1)
          echo "✅ Unit tests passed"

      - name: Generate image tag
        id: generate-tag
        run: |
          TAG="v1.0.${{ github.run_number }}"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "Generated tag: ${TAG}"
          
      - name: Set lowercase image name
        id: set-image-name
        run: |
          REPO_OWNER_LOWERCASE=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          FULL_IMAGE_NAME="${{ env.REGISTRY }}/$REPO_OWNER_LOWERCASE/${{ env.IMAGE_NAME }}"
          echo "full_image_name=$FULL_IMAGE_NAME" >> $GITHUB_OUTPUT


  # Stage 3: 3-Tier Stack Testing
  three-tier-tests:
    runs-on: ubuntu-latest
    needs: build-and-test
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: pip install -r requirements.txt requests
      
      - name: Build Docker image for local testing
        run: |
          IMAGE_TAG="${{ needs.build-and-test.outputs.full_image_name }}:${{ needs.build-and-test.outputs.tag }}"
          docker build -t "$IMAGE_TAG" .
          echo "Locally built image with tag: $IMAGE_TAG"

      - name: Inject dynamic image tag into docker-compose.yml
        run: |
          IMAGE_TAG="${{ needs.build-and-test.outputs.full_image_name }}:${{ needs.build-and-test.outputs.tag }}"
          sed -i "s|YOUR_APP_IMAGE_PLACEHOLDER|${IMAGE_TAG}|g" docker-compose/docker-compose.yml
          
      - name: Bring up 3-Tier Stack
        working-directory: ./docker-compose
        run: docker compose up -d --build --wait
        
      - name: Run 3-Tier Tests
        # Test nginx reverse proxy functionality, application health, and 3-tier architecture
        run: |
          echo "=== Running 3-Tier Stack Tests ==="
          sleep 20 # Give services time to start up
          curl --fail http://localhost:8080/ || { echo "ERROR: Nginx endpoint test failed!"; exit 1; }
          curl --fail http://localhost:8080/health || { echo "ERROR: Health endpoint test failed!"; exit 1; }
          
          echo "✅ 3-Tier Stack Tests Passed"

      - name: Cleanup 3-Tier Stack
        if: always()
        working-directory: ./docker-compose
        run: docker compose down -v || true
        
  # Stage 4: Publish
  publish:
    runs-on: ubuntu-latest
    needs: [build-and-test, three-tier-tests] # Ensure all tests pass before publishing
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Login to GitHub Container Registry (GHCR)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Build and push Docker image to GHCR
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ needs.build-and-test.outputs.full_image_name }}:latest
            ${{ needs.build-and-test.outputs.full_image_name }}:${{ needs.build-and-test.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        if: github.ref == 'refs/heads/main'
        with:
          tag_name: ${{ needs.build-and-test.outputs.tag }}
          name: Release ${{ needs.build-and-test.outputs.tag }}
          body: |
            - Auto-generated release
            - Image tag: ${{ needs.build-and-test.outputs.tag }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Stage 5: Kubernetes Deployment Testing
  k8s-deployment-testing:
    runs-on: ubuntu-latest
    needs: publish
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create kind cluster for testing
        run: |
          echo "=== CD: Creating Test Environment ==="
          curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind
          kind create cluster --wait 300s
          echo "Test cluster created successfully"
          kubectl cluster-info
          kubectl get nodes

      - name: Create imagePullSecret for GHCR
        run: |
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --docker-email=example@example.com
          
      - name: Deploy Workprofile application
        run: |
          TAG="${{ needs.build-and-test.outputs.tag }}"
          REPO_OWNER_LOWERCASE=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          IMAGE="${{ env.REGISTRY }}/${REPO_OWNER_LOWERCASE}/${{ env.IMAGE_NAME }}:${TAG}"
          echo "=== CD: Deploying Workprofile Application ==="
          echo "Updating deployment with image: ${IMAGE}"
          sed -i "s|IMAGE_PLACEHOLDER|${IMAGE}|g" k8s/workprofile-deployment.yaml
          
          # Deploying MySQL and Workprofile components
          kubectl apply -f k8s/mysql-secret.yaml
          kubectl create configmap mysql-initdb-config --from-file=init.sql=init.sql
          kubectl apply -f k8s/mysql-statefulset.yaml
          kubectl apply -f k8s/mysql-service.yaml
          kubectl wait --for=condition=ready pod/mysql-0 --timeout=300s
          kubectl apply -f k8s/workprofile-configmap.yaml
          kubectl apply -f k8s/workprofile-deployment.yaml
          kubectl apply -f k8s/workprofile-service.yaml
          kubectl wait --for=condition=available deployment/workprofile --timeout=300s
          
          echo "Workprofile deployment successful"
          kubectl get pods,svc,deployment -l app=workprofile

      - name: Run K8s Health Checks
        run: |
          echo "=== CD: Verifying Production-Ready Stack ==="
          kubectl port-forward deployment/workprofile 5000:5000 &
          PORT_FORWARD_PID=$!
          
          sleep 20
          
          if curl -f http://localhost:5000/; then
            echo "Workprofile application: SUCCESS"
          else
            echo "Workprofile application test failed"
            kubectl logs -l app=workprofile
            exit 1
          fi
          
          kill $PORT_FORWARD_PID
          echo "Production-ready stack verification: SUCCESS"

      - name: Cleanup Kubernetes Cluster
        if: always()
        run: |
          kind delete cluster || true
          echo "Kind cluster deleted."

  # Stage 6: Manual Deployment Instructions
  manual-deployment-instructions:
    runs-on: ubuntu-latest
    needs: k8s-deployment-testing # This job runs only after all previous stages pass
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Display Deployment Instructions
        run: |
          TAG="${{ needs.build-and-test.outputs.tag }}"
          REPO_OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          IMAGE_TO_DEPLOY="ghcr.io/${REPO_OWNER_LOWER}/${{ env.IMAGE_NAME }}:${TAG}"

          echo "=== CI/CD Pipeline Complete! ==="
          echo ""
          echo "Your production-ready stack is ready! To deploy manually to Killercoda:"
          echo ""
          echo "1. In your Killercoda terminal, clone and prepare:"
          echo "     git clone https://github.com/${{ github.repository }}.git"
          echo "     cd WorkProfile"
          echo ""
          echo "2. Inject image tag and deploy:"
          echo "     IMAGE_TO_DEPLOY=\"${IMAGE_TO_DEPLOY}\""
          echo "     sed \"s|YOUR_APP_IMAGE_PLACEHOLDER|\$IMAGE_TO_DEPLOY|g\" k8s/workprofile-deployment.yaml > workprofile-deployment-temp.yaml"
          echo "     echo \"\""
          echo "     echo \"--- בדיקת התוכן ---\""
          echo "     cat workprofile-deployment-temp.yaml"
          echo "     echo \"\""
          echo ""
          echo "3. Deploy MySQL infrastructure first:"
          echo "     kubectl apply -f k8s/mysql-secret.yaml"
          echo "     kubectl apply -f k8s/mysql-statefulset.yaml"
          echo "     kubectl apply -f k8s/mysql-service-headless.yaml"
          echo "     kubectl apply -f k8s/mysql-service-clusterip.yaml"
          echo "     kubectl wait --for=condition=ready pod/mysql-0 --timeout=600s"
          echo ""
          echo "4. Deploy Workprofile application:"
          echo "     kubectl apply -f k8s/workprofile-configmap.yaml"
          echo "     kubectl apply -f k8s/workprofile-deployment-temp.yaml"
          echo "     kubectl apply -f k8s/workprofile-service.yaml"
          echo "     kubectl wait --for=condition=available deployment/workprofile --timeout=600s"
          echo ""
          echo "5. Run health checks:"
          echo "     NODE_PORT=\$(kubectl get service workprofile-service -o jsonpath='{.spec.ports[0].nodePort}')"
          echo "     echo \"WorkProfile NodePort: \$NODE_PORT\""
          echo ""
          echo "     NODE_IP=\$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type==\"InternalIP\")].address}')"
          echo "     echo \"Node IP: \$NODE_IP\""
          echo ""
          echo "     curl -f http://\$NODE_IP:\$NODE_PORT/ && echo \"✓ Kubernetes app works\""
          echo "     curl -f http://\$NODE_IP:\$NODE_PORT/health && echo \"✓ Kubernetes health works\""
          echo "     curl -s http://\$NODE_IP:\$NODE_PORT/health | grep \"Application: Healthy\" && echo \"✓ Kubernetes database works (via app health)\""
          echo ""
          echo "6. Cleanup your environment:"
          echo "     kubectl delete -f k8s/mysql-secret.yaml"
          echo "     kubectl delete -f k8s/mysql-service-headless.yaml"
          echo "     kubectl delete -f k8s/mysql-service-clusterip.yaml"
          echo "     kubectl delete -f k8s/mysql-statefulset.yaml"
          echo "     kubectl delete -f k8s/workprofile-configmap.yaml"
          echo "     kubectl delete -f k8s/workprofile-service.yaml"
          echo "     kubectl delete -f workprofile-deployment-temp.yaml"
          echo "     kubectl delete pvc mysql-persistent-storage-mysql-0"
          echo "     rm workprofile-deployment-temp.yaml"
          echo ""
          echo "=== Production Architecture Deployed ==="
